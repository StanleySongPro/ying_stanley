WEBVTT

1
00:00:04.780 --> 00:00:08.570
In the last video we went over some basic
concepts about joins that are summarized

2
00:00:08.570 --> 00:00:10.340
in this diagram.

3
00:00:10.340 --> 00:00:14.760
Inner joins keep everything that's common
to two tables, not including null values.

4
00:00:14.760 --> 00:00:17.980
Left joins keep everything in
the left table, including nulls, and

5
00:00:17.980 --> 00:00:20.990
include only matching information
from the table in the right.

6
00:00:20.990 --> 00:00:24.260
Right joins keep everything in
the right table, including nulls, and

7
00:00:24.260 --> 00:00:26.930
include only matching information
from the table on the left.

8
00:00:26.930 --> 00:00:29.910
And full outer joins,
which are not supported by Bi SQL,

9
00:00:29.910 --> 00:00:33.140
include every row from both tables and
match them up whenever possible.

10
00:00:34.290 --> 00:00:37.550
All of these concepts are accurate, and
this picture is a good reference that you

11
00:00:37.550 --> 00:00:40.530
will see often in textbooks or
on the Internet, but it can also be

12
00:00:40.530 --> 00:00:44.100
a little misleading if you forget about
the concept of Cartesian products.

13
00:00:44.100 --> 00:00:47.550
You'll see why when you start working
with concepts whose maximum carnality

14
00:00:47.550 --> 00:00:48.919
constraints are greater than 1.

15
00:00:50.050 --> 00:00:52.550
For example,
the diagram makes it look like

16
00:00:52.550 --> 00:00:56.510
all inner joins will have output tables
that are smaller than the input tables.

17
00:00:56.510 --> 00:01:00.750
However, that will often not be true if
values in one of your tables can be linked

18
00:01:00.750 --> 00:01:02.920
up to many values in the other table.

19
00:01:02.920 --> 00:01:06.140
To see how that could happen, let's
work through an example step by step.

20
00:01:07.390 --> 00:01:10.600
Let's join employees with their
departments again, but this time each

21
00:01:10.600 --> 00:01:15.330
employee can be in many departments and
each department can have many employees.

22
00:01:15.330 --> 00:01:18.615
Recall from the first week of the course
that in order to put concepts that have

23
00:01:18.615 --> 00:01:22.100
many-to-many relationships into
a relational database you always need to

24
00:01:22.100 --> 00:01:26.270
have a linking table that has foreign keys
of the tables you ultimately want to link.

25
00:01:26.270 --> 00:01:29.420
So under these circumstances,
we will need to join three tables

26
00:01:29.420 --> 00:01:32.590
to ultimately combine employee and
department information.

27
00:01:32.590 --> 00:01:35.910
When you join multiple tables,
you join two at a time and

28
00:01:35.910 --> 00:01:39.360
then join the results of each
join with subsequent tables.

29
00:01:40.380 --> 00:01:43.370
Therefore, to join the information
in the employee table with

30
00:01:43.370 --> 00:01:45.270
the information in the department table,

31
00:01:45.270 --> 00:01:48.050
first we have to join the employees
table to the assignment table.

32
00:01:49.080 --> 00:01:52.980
When we execute this join, the database
will make all the possible combinations of

33
00:01:52.980 --> 00:01:57.190
rows between the tables for the Cartesian
product as long as the employee IDs match.

34
00:01:58.370 --> 00:02:02.200
In this case, sometimes there are multiple
assignment rows with the same employee ID,

35
00:02:02.200 --> 00:02:04.850
so the join will output each
combination of employee and

36
00:02:04.850 --> 00:02:07.720
assignment rows that have
the same employee ID numbers.

37
00:02:07.720 --> 00:02:12.050
As a result, the inner join will output
eight rows even though the Employee table

38
00:02:12.050 --> 00:02:14.820
is only five rows and
has one null value that is included.

39
00:02:15.990 --> 00:02:17.860
When we join the results
of our first join,

40
00:02:17.860 --> 00:02:22.320
the Department table, six of those initial
eight rows will still be retained because

41
00:02:22.320 --> 00:02:25.710
all six of those rows have matching
department IDs in the Department table.

42
00:02:25.710 --> 00:02:26.310
So, in the end,

43
00:02:26.310 --> 00:02:30.710
the result of our inner join has more rows
than either of the tables we were joining.

44
00:02:30.710 --> 00:02:33.880
Remember that this is possible every time
you look at the slightly misleading but

45
00:02:33.880 --> 00:02:36.590
still very useful picture for reference.

46
00:02:36.590 --> 00:02:39.460
There's also another aspect of joins
that's hard to appreciate when looking at

47
00:02:39.460 --> 00:02:42.780
this picture, and that happens when
you join multiple tables together

48
00:02:42.780 --> 00:02:46.330
using different types of joins,
which often means you accidentally

49
00:02:46.330 --> 00:02:49.690
join multiple tables together
using different types of joins.

50
00:02:49.690 --> 00:02:53.570
To see what I mean, let's link our
Employee and Department tables up again.

51
00:02:53.570 --> 00:02:57.040
But this time, we want to use a left join
because we want the full list of all

52
00:02:57.040 --> 00:03:00.610
the employees, regardless of whether
they are assigned to a department.

53
00:03:00.610 --> 00:03:04.720
You can see this time,
the result of our first join has nine rows

54
00:03:04.720 --> 00:03:08.650
because the known value in row five
of the employee table is included.

55
00:03:08.650 --> 00:03:10.200
So far so good.

56
00:03:10.200 --> 00:03:12.900
If we then use another left joint
to connect the result of that

57
00:03:12.900 --> 00:03:17.220
first joint to department table, we would
retain all nine rows in the output, and

58
00:03:17.220 --> 00:03:20.690
three of those rows would have no
values in the department column.

59
00:03:20.690 --> 00:03:24.700
But now, what if we forgot the word left
in our second joint statement, so that we

60
00:03:24.700 --> 00:03:28.050
accidentally computed an inner joint
between the results of our first joint and

61
00:03:28.050 --> 00:03:28.680
department table?

62
00:03:29.810 --> 00:03:32.290
Now, four of our nine
rows would be removed,

63
00:03:32.290 --> 00:03:35.130
because they don't have department ID's
that are present in the department table.

64
00:03:35.130 --> 00:03:38.800
If you have a really large dataset, and
we're aggregating over the results,

65
00:03:38.800 --> 00:03:41.585
rather than looking at each row
of the join output on it's own

66
00:03:41.585 --> 00:03:44.955
Query would certainly run but your results
would not be what you think they are.

67
00:03:44.955 --> 00:03:48.125
And it might be hard to
notice that major mistake.

68
00:03:48.125 --> 00:03:51.095
Sometimes you do intentionally want
to vary your join types when you're

69
00:03:51.095 --> 00:03:51.965
combining tables.

70
00:03:51.965 --> 00:03:55.215
So I don't want you to think that you
always have to use the same join type.

71
00:03:55.215 --> 00:03:57.975
Instead, I just want you to remember
that the order in which you

72
00:03:57.975 --> 00:03:59.575
run your joins matters.

73
00:03:59.575 --> 00:04:02.225
So you need to make sure that you
are applying the correct type of join,

74
00:04:02.225 --> 00:04:04.715
to the correct pairs of tables and
the correct point in your query.

75
00:04:06.080 --> 00:04:08.540
There's one more thing you need
to remember about joins, and

76
00:04:08.540 --> 00:04:11.940
that's what happens when you join
tables that have duplicate rows.

77
00:04:11.940 --> 00:04:15.950
Joins retain duplicate rows in output
tables because there's no mechanism within

78
00:04:15.950 --> 00:04:19.440
the concept of a join on its
own that would remove them.

79
00:04:19.440 --> 00:04:22.960
So a left join of these two
tables would look like this.

80
00:04:22.960 --> 00:04:25.520
The duplicated rows in the employee
table gets passed along to

81
00:04:25.520 --> 00:04:27.280
the results of the join.

82
00:04:27.280 --> 00:04:30.730
Thanks to Cartesian products, things can
get a little challenging when you join two

83
00:04:30.730 --> 00:04:35.540
tables that not only have duplicates but
also have many to many relationships.

84
00:04:35.540 --> 00:04:37.970
Essentially what happens is that
your duplicates get multiplied.

85
00:04:39.120 --> 00:04:42.970
Let's go back to our join of the employees
pointed to and department tables.

86
00:04:42.970 --> 00:04:45.740
Now we have a pair of duplicate
rows in the Employees table and

87
00:04:45.740 --> 00:04:48.280
a pair of duplicate rows
in the Departments table.

88
00:04:48.280 --> 00:04:52.170
When we make our first inner join with
the employees in a appointed to table.

89
00:04:52.170 --> 00:04:55.810
Each of those duplicates is going to get
multiplied by all the rows in the linking

90
00:04:55.810 --> 00:04:58.110
table that have the same employee ID.

91
00:04:58.110 --> 00:05:01.970
So the output will give you a duplicate of
each of the rows in the linking table that

92
00:05:01.970 --> 00:05:03.490
have the employee ID of DD.

93
00:05:03.490 --> 00:05:06.840
But it gets even more
complicated than that.

94
00:05:06.840 --> 00:05:10.530
When we inner join the output of that
first joint to the Department's table,

95
00:05:10.530 --> 00:05:14.290
each of the rows have a department
idea of 1, will get duplicated.

96
00:05:14.290 --> 00:05:16.720
So, the final results will look like this.

97
00:05:16.720 --> 00:05:20.120
You can see that we went from having two
rows of data from the employee Daisy

98
00:05:20.120 --> 00:05:22.410
to six rows of data from
the employee Daisy,

99
00:05:22.410 --> 00:05:24.839
even though only two of those
rows represent real records.

100
00:05:26.370 --> 00:05:28.870
This is what can happen
when you join duplicates.

101
00:05:28.870 --> 00:05:31.830
You could imagine how out of hand
these multiplicative effects can get

102
00:05:31.830 --> 00:05:33.680
if you join lots of duplicates.

103
00:05:33.680 --> 00:05:36.400
In fact, we are going to see an example
of that with our Dognition dataset.

104
00:05:36.400 --> 00:05:40.580
Now that you have seen the types of things
that can happen with messy datasets you

105
00:05:40.580 --> 00:05:43.450
might be able to sympathize with the
database people who want to use different

106
00:05:43.450 --> 00:05:47.010
terminology for the design of
a database versus a real database.

107
00:05:47.010 --> 00:05:51.470
Database design, based on set theory,
assumes there are no duplicate rows.

108
00:05:51.470 --> 00:05:55.660
In real life there are duplicate rows and
they can be very challenging to work with.

109
00:05:55.660 --> 00:06:00.090
Using terminology that differentiates
theory from real life can be useful.

110
00:06:00.090 --> 00:06:02.230
In terms of what to do
about these duplicate rows,

111
00:06:02.230 --> 00:06:04.410
here are some good practices to follow.

112
00:06:04.410 --> 00:06:07.690
First whenever possible it's
a good idea to clean your data and

113
00:06:07.690 --> 00:06:10.990
get rid of as many duplicates as
you can before doing your analysis.

114
00:06:10.990 --> 00:06:13.370
But sometimes that's not practical or
possible.

115
00:06:13.370 --> 00:06:16.650
So you should get in the habit of looking
at small testing examples of the rows that

116
00:06:16.650 --> 00:06:18.960
will be outputted by every
pair of tables you join.

117
00:06:18.960 --> 00:06:23.290
Before you ink multiple joins together
in one query step by step make sure

118
00:06:23.290 --> 00:06:26.730
each individual joint you are going to
run gives you the results you expect

119
00:06:26.730 --> 00:06:30.780
before you start aggregating the results
of the join or doing anything else fancy.

120
00:06:30.780 --> 00:06:33.952
This will also help that you make sure
you don't enter the wrong kind of join at

121
00:06:33.952 --> 00:06:35.180
a given step.

122
00:06:35.180 --> 00:06:38.160
Taking the time to double check each part
of your query at the beginning of your

123
00:06:38.160 --> 00:06:40.790
analysis, will save you from
having a lot of trouble later on,

124
00:06:40.790 --> 00:06:44.060
due to misinterpreting results that
you didn't know were incorrect.

125
00:06:44.060 --> 00:06:45.340
So I highly recommend this habit.

126
00:06:45.340 --> 00:06:48.240
It will make sure that you
have control of your joins,

127
00:06:48.240 --> 00:06:50.220
rather than letting them control you.

128
00:06:50.220 --> 00:06:52.990
With all this knowledge,
you are ready to join some tables.

129
00:06:52.990 --> 00:06:55.290
Have fun, and
don't forget about Cartesian products.