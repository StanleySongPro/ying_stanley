WEBVTT

1
00:00:04.165 --> 00:00:08.618
We've talked a lot about how relational
databases work by breaking large data sets

2
00:00:08.618 --> 00:00:12.100
up into smaller tables of
data with unified themes.

3
00:00:12.100 --> 00:00:13.840
We generally try to organize our themes so

4
00:00:13.840 --> 00:00:17.080
that we replicate individual data
entries as rarely as possible.

5
00:00:17.080 --> 00:00:17.850
Of course,

6
00:00:17.850 --> 00:00:21.850
this strategy only works if we can put
the tables back together when we need to.

7
00:00:21.850 --> 00:00:24.590
We achieve this using a class
of SQL commands called joins.

8
00:00:25.630 --> 00:00:28.520
Joins have a bad reputation
among new SQL users, but

9
00:00:28.520 --> 00:00:31.240
in my experiences joins
are only hard to understand if

10
00:00:31.240 --> 00:00:34.650
you don't have a firm grasp of how
relational databases are set up.

11
00:00:34.650 --> 00:00:37.060
Since you mastered the material
in week one of this course,

12
00:00:37.060 --> 00:00:40.220
you do have a firm grasp of how
relational databases are set up.

13
00:00:40.220 --> 00:00:42.530
So you will master joins very quickly.

14
00:00:42.530 --> 00:00:45.380
By the end of this video,
you'll understand how joins work and

15
00:00:45.380 --> 00:00:46.560
why there are different kinds of them.

16
00:00:48.060 --> 00:00:49.960
To understand what joins are,

17
00:00:49.960 --> 00:00:52.570
let's consider the problem
they are meant to solve.

18
00:00:52.570 --> 00:00:54.950
Recalling the tables we made for
our Egger's roast coffee database.

19
00:00:54.950 --> 00:00:59.110
Let's focus on just two of those tables,
the orders table and

20
00:00:59.110 --> 00:01:02.600
the distribution center table,
and let's zoom in a little bit.

21
00:01:02.600 --> 00:01:06.080
You can see that in order for us to learn
any information about the distribution

22
00:01:06.080 --> 00:01:07.670
center of the items in the orders table,

23
00:01:07.670 --> 00:01:11.510
you have to link each row of the orders
table data to the appropriate row of

24
00:01:11.510 --> 00:01:15.230
the distribution center table data by
matching up the distribution location ID.

25
00:01:16.230 --> 00:01:19.110
So far, we have talked about linking
tables as a general concept for

26
00:01:19.110 --> 00:01:22.100
organizing databases, but
now we have to think about the details of

27
00:01:22.100 --> 00:01:24.710
how the database can
actually make that look.

28
00:01:24.710 --> 00:01:29.532
Take a second to think about at least

29
00:01:29.532 --> 00:01:34.355
one strategy a database could use to

30
00:01:34.355 --> 00:01:38.868
link these two tables together.

31
00:01:38.868 --> 00:01:42.320
One of the first strategies that might
come to mind is that the database could go

32
00:01:42.320 --> 00:01:45.983
through the distribution center ID column
of the order's table row by row and ask,

33
00:01:45.983 --> 00:01:47.900
which distribution center ID is this?

34
00:01:47.900 --> 00:01:48.930
It's dl1?

35
00:01:48.930 --> 00:01:49.896
Okay, in that case,

36
00:01:49.896 --> 00:01:54.010
it matches up with all the data in
the dl1 row of the distribution center.

37
00:01:54.010 --> 00:01:56.950
You could implement this strategy in
Excel with a VLOOKUP function, and

38
00:01:56.950 --> 00:02:00.070
it would work very well if your
data set wasn't too large.

39
00:02:00.070 --> 00:02:03.010
But what if you had to copy
the VLOOKUP function to 100 million

40
00:02:03.010 --> 00:02:05.900
rows spread across multiple
spreadsheets in Excel?

41
00:02:05.900 --> 00:02:08.930
Even if you're an Excel expert,
it would take a bit of time to even paste

42
00:02:08.930 --> 00:02:12.440
the VLOOKUP formulas into
all the appropriate cells,

43
00:02:12.440 --> 00:02:15.490
although a computer is much quicker than
a human at these types of operations.

44
00:02:15.490 --> 00:02:18.310
A similar concept still holds for
a database.

45
00:02:18.310 --> 00:02:20.960
Operations that make
databases look information up

46
00:02:20.960 --> 00:02:24.620
are always relatively slow compared to
other types of mathematical operations.

47
00:02:24.620 --> 00:02:28.110
And the more times a database has to look
up that information or the wider the pool

48
00:02:28.110 --> 00:02:31.940
of information it has to search,
the slower the database query will be.

49
00:02:31.940 --> 00:02:34.710
So the row by row strategy
is going to be inefficient.

50
00:02:34.710 --> 00:02:36.210
Is there another strategy we could use?

51
00:02:37.330 --> 00:02:39.910
For those of you who've done
a lot of analysis using MATLAB or

52
00:02:39.910 --> 00:02:43.530
R software you might be thinking isn't
there someway we could do this using

53
00:02:43.530 --> 00:02:46.540
a matrix algebra if we treat
each table as a matrix?

54
00:02:46.540 --> 00:02:48.230
Well I sympathize with that statement, but

55
00:02:48.230 --> 00:02:51.770
I'm not sure what the strategy would be,
given that in most cases the tables you

56
00:02:51.770 --> 00:02:53.970
will be combining will not be
of the same length or width.

57
00:02:55.040 --> 00:02:57.850
Here's where set theory
comes to the rescue.

58
00:02:57.850 --> 00:03:01.685
The theoretical way set theory combines
two sets is by multiplying them,

59
00:03:01.685 --> 00:03:05.285
resulting in what is called
the Cartesian product, or cross product.

60
00:03:05.285 --> 00:03:09.225
In the case of sets, multiplication
doesn't mean multiplying numerical values.

61
00:03:09.225 --> 00:03:12.555
The Cartesian product is a set that
contains all the possible pairs of items

62
00:03:12.555 --> 00:03:14.045
in two tables.

63
00:03:14.045 --> 00:03:17.765
If this was our orders table, or set,
and this was our distribution table, or

64
00:03:17.765 --> 00:03:21.450
set, this would be the Cartesian
product of the two sets.

65
00:03:21.450 --> 00:03:24.410
You can see that the Cartesian product
gives every possible combination

66
00:03:24.410 --> 00:03:25.570
of the rows.

67
00:03:25.570 --> 00:03:29.890
The way databases combine tables is by
first filtering the columns you are using

68
00:03:29.890 --> 00:03:33.520
to link tables together by the criteria
you specify in your query,

69
00:03:33.520 --> 00:03:36.670
then it makes the Cartesian
products of these filtered columns.

70
00:03:36.670 --> 00:03:40.960
And finally, it appends any additional
columns that you asked for in your query.

71
00:03:40.960 --> 00:03:45.400
So the way you can join tables in your
queries to get data you want is to specify

72
00:03:45.400 --> 00:03:48.710
I only want the Cartesian product
of rows that have the same IDs and

73
00:03:48.710 --> 00:03:49.820
a unique ID column.

74
00:03:50.890 --> 00:03:53.650
You need to know about cartesian
products because sometimes you get

75
00:03:53.650 --> 00:03:56.410
unexpected outputs when you join
tables that have duplicate rows or

76
00:03:56.410 --> 00:03:58.570
columns that have many
to many relationships.

77
00:03:58.570 --> 00:04:01.460
These outputs will only make sense if
you remember the fundamental notion

78
00:04:01.460 --> 00:04:04.310
that Cartesian products underline joins.

79
00:04:04.310 --> 00:04:07.870
We're going to work our way up to
understanding those types of situations.

80
00:04:07.870 --> 00:04:11.570
But let's start by thinking about joins
in the perfect idyllic situation when you

81
00:04:11.570 --> 00:04:13.140
have no duplicate rows, and

82
00:04:13.140 --> 00:04:17.270
each row in one table is only
connected to one row on another table.

83
00:04:17.270 --> 00:04:20.920
Imagine that you have the following two
tables that are linked by department ID.

84
00:04:20.920 --> 00:04:24.090
There are at least four different
ways you can combine these tables.

85
00:04:24.090 --> 00:04:27.310
The first would be if you wanted to
find out all the employees who work in

86
00:04:27.310 --> 00:04:28.820
a current department.

87
00:04:28.820 --> 00:04:31.780
In this case, you want a list of
all the employee rows which have

88
00:04:31.780 --> 00:04:34.380
matching department IDs
in the department table.

89
00:04:34.380 --> 00:04:38.615
This type of join, where a row is only
included if its value is contained in both

90
00:04:38.615 --> 00:04:41.325
unique columns of a table
is called an inner join.

91
00:04:41.325 --> 00:04:44.359
The result of an inner join of these
two tables will look like this.

92
00:04:45.760 --> 00:04:49.760
Since there is no department ID of 4 or
5 in the department table, and

93
00:04:49.760 --> 00:04:54.190
no department ID of 3 in the employee
table, the name Jessica, the name Daisy,

94
00:04:54.190 --> 00:04:56.770
and the department of furniture
will be left out of the result.

95
00:04:58.050 --> 00:05:01.450
Also notice that the employee Brian and
the department Cosmetics were dropped from

96
00:05:01.450 --> 00:05:05.420
the results because NULL values can
never be used to link rows in a join.

97
00:05:05.420 --> 00:05:07.920
Null values are not linked
up to other linked values.

98
00:05:07.920 --> 00:05:08.920
They're simply excluded.

99
00:05:10.440 --> 00:05:13.910
What if you wanted a list of all the
employees and their departments regardless

100
00:05:13.910 --> 00:05:17.410
of whether the employee's department
was in the current department table?

101
00:05:17.410 --> 00:05:19.760
In this case, you could use an outer join.

102
00:05:19.760 --> 00:05:21.090
When you write an outer join,

103
00:05:21.090 --> 00:05:24.130
the order you enter the tables
into your query matters.

104
00:05:24.130 --> 00:05:27.980
The name of the join defines which table
will have all of it's values included.

105
00:05:27.980 --> 00:05:30.410
Let's assume we will enter
the employee table first and

106
00:05:30.410 --> 00:05:32.750
the apartment table second in our query.

107
00:05:32.750 --> 00:05:36.410
In this case, the result of the LEFT outer
join of these two tables would result in

108
00:05:36.410 --> 00:05:37.920
all of the values of
the table on the left,

109
00:05:37.920 --> 00:05:40.930
in the Employees table being included.

110
00:05:40.930 --> 00:05:43.630
Values in the table on the right
would only be included if they have

111
00:05:43.630 --> 00:05:46.510
a value in their linking column that
matches up with the linking column in

112
00:05:46.510 --> 00:05:47.240
the table on the left.

113
00:05:48.290 --> 00:05:50.890
Here's what a result of a left join
on our tables would look like.

114
00:05:52.160 --> 00:05:55.330
You see here that all of our employees
are included in the output, but

115
00:05:55.330 --> 00:05:57.990
the only departments that are included
are those that have a matching

116
00:05:57.990 --> 00:06:00.220
value in the Department ID column.

117
00:06:00.220 --> 00:06:03.160
Notice that wherever there was a row
in the employee table that didn't have

118
00:06:03.160 --> 00:06:07.490
a matching department ID in the Department
table, the department is listed as NULL.

119
00:06:07.490 --> 00:06:10.770
The road that had a null value in the
employees table is included in the output

120
00:06:10.770 --> 00:06:13.930
table this time because there is no
criterion that it had to much up with

121
00:06:13.930 --> 00:06:14.940
a value in another column.

122
00:06:16.350 --> 00:06:19.040
You could also retrieve a list of
all the current departments and

123
00:06:19.040 --> 00:06:22.980
their employees, regardless of whether
any employees in the employee table

124
00:06:22.980 --> 00:06:25.550
were pointed to a department
in the department table.

125
00:06:25.550 --> 00:06:28.760
If we once again include the employee
table first and the department table

126
00:06:28.760 --> 00:06:32.830
second in our query, we could acquire
this list using a right outer join.

127
00:06:32.830 --> 00:06:36.750
In right joins, all the results of
the table on the right are included.

128
00:06:36.750 --> 00:06:40.080
Values of the table on the left
are included only if they have a value in

129
00:06:40.080 --> 00:06:43.930
their linking column that matches up with
the linking column in table on the right.

130
00:06:43.930 --> 00:06:45.420
So the results would look like this.

131
00:06:46.740 --> 00:06:49.930
This time, all of the department
rows are included in the output.

132
00:06:49.930 --> 00:06:53.130
However, the furniture row has
a null value in the employee table,

133
00:06:53.130 --> 00:06:56.260
because there is no department ID 3
listed anywhere in the department ID

134
00:06:56.260 --> 00:06:58.200
column of the employees table.

135
00:06:58.200 --> 00:07:00.650
The row of data in the department
table had a null value and

136
00:07:00.650 --> 00:07:03.130
department ID is included in the output.

137
00:07:03.130 --> 00:07:06.300
On the other hand, the rows of data
from the employee table that do not have

138
00:07:06.300 --> 00:07:08.940
department IDs that appear in
the department table are excluded.

139
00:07:10.420 --> 00:07:13.950
At this point you might be thinking,
wait, couldn't I get the same result

140
00:07:13.950 --> 00:07:16.450
if I ran the join we just
described using a left join but

141
00:07:16.450 --> 00:07:18.910
reversed the order of the tables
I enter into the query?

142
00:07:18.910 --> 00:07:21.540
The answer is yes, yes you could.

143
00:07:21.540 --> 00:07:23.820
Left and
right outer joins are fairly redundant.

144
00:07:23.820 --> 00:07:26.470
They just give you flexibility
in how you write your query.

145
00:07:26.470 --> 00:07:29.800
A left outer join with the tables written
in this order gives you the same result

146
00:07:29.800 --> 00:07:31.860
as a right outer join with
the tables written in this order.

147
00:07:33.300 --> 00:07:35.930
There is one more type of
join we haven't talked about.

148
00:07:35.930 --> 00:07:37.730
Full outer joins.

149
00:07:37.730 --> 00:07:41.390
Full outer joins would give you all the
employees and departments list in one or

150
00:07:41.390 --> 00:07:42.480
the other table,

151
00:07:42.480 --> 00:07:45.620
regardless of whether they match
up with values in the other table.

152
00:07:45.620 --> 00:07:48.890
You might use this if you simply wanted
to extract all of the data that meet

153
00:07:48.890 --> 00:07:50.490
a certain criterion, so

154
00:07:50.490 --> 00:07:53.810
that you can examine every single
piece of raw data in your analysis.

155
00:07:53.810 --> 00:07:57.210
The result of a full outer join between
our two tables would look like this.

156
00:07:58.310 --> 00:08:01.790
You can see all rows are included, and
whenever there was a row that didn't have

157
00:08:01.790 --> 00:08:04.849
a matching value in the department
ID column, no values are entered.

158
00:08:06.050 --> 00:08:09.650
One important thing to know is that not
all database management systems support

159
00:08:09.650 --> 00:08:11.110
full outer joins.

160
00:08:11.110 --> 00:08:15.790
MySQL in particular does not support
full joins while Teradata does.

161
00:08:15.790 --> 00:08:19.560
The fact that not all database management
systems support full outer joins gives you

162
00:08:19.560 --> 00:08:21.850
a sense of how rarely they are used.

163
00:08:21.850 --> 00:08:24.290
So those are the basic
concepts behind joins.

164
00:08:24.290 --> 00:08:26.690
They are summarized in this diagram
that you might want to keep for

165
00:08:26.690 --> 00:08:27.920
future reference.

166
00:08:27.920 --> 00:08:30.100
Not too bad so far, right, I agree.

167
00:08:31.120 --> 00:08:34.850
That said, so far we have only looked at
the results of joining tables that have

168
00:08:34.850 --> 00:08:38.280
columns that have only one match
per value in their linking column.

169
00:08:38.280 --> 00:08:41.520
The results do get slightly more
complicated when you apply outer joints to

170
00:08:41.520 --> 00:08:45.580
tables who relationships have cardinality
constraints that are greater than one.

171
00:08:45.580 --> 00:08:47.840
Or if some of your tables
have duplicate rows.

172
00:08:47.840 --> 00:08:51.760
I hope you will join me and your tables
in the next video to find out why.