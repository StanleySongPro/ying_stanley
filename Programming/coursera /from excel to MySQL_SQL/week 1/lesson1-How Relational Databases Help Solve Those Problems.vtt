WEBVTT

1
00:00:03.665 --> 00:00:07.460
How would you design a data storage
system that wasn't a single spread sheet?

2
00:00:08.590 --> 00:00:12.140
Well, if you have to read and
write a lot of data really quickly

3
00:00:12.140 --> 00:00:15.610
you want the reading and writing
process to be as efficient as possible.

4
00:00:15.610 --> 00:00:18.970
You also want the data to take
up as little space as possible.

5
00:00:18.970 --> 00:00:22.500
In this course, we are focusing on
how a certain kind of database,

6
00:00:22.500 --> 00:00:25.540
relational databases like My SQL,
Teradata, and

7
00:00:25.540 --> 00:00:30.390
others achieve the goals of writing and
retrieving lots of data quickly.

8
00:00:30.390 --> 00:00:33.240
The fundamental concept behind
relational databases is

9
00:00:33.240 --> 00:00:37.620
that they break up data sets into
individual pieces or subsets of data.

10
00:00:37.620 --> 00:00:41.300
Each subset of the data will have a theme
that logically binds the data records and

11
00:00:41.300 --> 00:00:42.210
that subset together.

12
00:00:43.250 --> 00:00:46.920
When you ask to retrieve information, the
database only interacts with the subsets

13
00:00:46.920 --> 00:00:49.890
of data it needs to provide
the information you asked for

14
00:00:49.890 --> 00:00:52.470
rather than interacting with
the entire dataset at the same time.

15
00:00:53.470 --> 00:00:56.190
This general strategy ensures
that the data require as little

16
00:00:56.190 --> 00:00:58.300
space as possible to store.

17
00:00:58.300 --> 00:01:01.070
As we will see in a second it
also provides mechanisms for

18
00:01:01.070 --> 00:01:03.420
retrieving the information that we ask for
very quickly.

19
00:01:03.420 --> 00:01:07.890
Let me tell you a little bit more, what
I meant when I said relational databases

20
00:01:07.890 --> 00:01:11.670
break data sets up into individual
pieces or sub sets data.

21
00:01:11.670 --> 00:01:15.270
It turns out that each sub set of
data is kept in its own table.

22
00:01:15.270 --> 00:01:18.150
So basically what relational databases do

23
00:01:18.150 --> 00:01:22.820
is organize data sets into smaller tables
that each have their own unified theme.

24
00:01:22.820 --> 00:01:25.910
If you think through what it would be
like to keep all the company's data in

25
00:01:25.910 --> 00:01:28.500
multiple spreadsheets,
it becomes clear that linking

26
00:01:28.500 --> 00:01:31.990
together spreadsheets would be a huge
time consuming problem if you didn't

27
00:01:31.990 --> 00:01:35.640
think about how you would combine and
relate the spreadsheets ahead of time.

28
00:01:35.640 --> 00:01:38.460
A similar concept holds
in relational databases.

29
00:01:38.460 --> 00:01:41.520
A critical piece of database
design is making sure each

30
00:01:41.520 --> 00:01:44.140
individual table with its
own unified theme contains

31
00:01:44.140 --> 00:01:47.720
a column with unique values that allows
you to link that table to other tables.

32
00:01:48.750 --> 00:01:51.940
Let's get a sense of what this may
look like by taking a first pass at

33
00:01:51.940 --> 00:01:53.350
how we could design a strategy for

34
00:01:53.350 --> 00:01:56.399
putting the Egger's Roast Coffee spread
sheet into a relational database.

35
00:01:57.790 --> 00:02:01.030
It seems like we have a bunch of
themes in our large spreadsheet.

36
00:02:01.030 --> 00:02:04.720
Company contact information,
loyalty program information,

37
00:02:04.720 --> 00:02:09.580
distribution center information, Egger's
Roast Coffee employee information and,

38
00:02:09.580 --> 00:02:12.020
of course, order information.

39
00:02:12.020 --> 00:02:15.890
So in order to put our large spreadsheet
into a relational database, we could break

40
00:02:15.890 --> 00:02:20.520
the large spread sheet down into separate
tables that each have one of these themes.

41
00:02:20.520 --> 00:02:23.412
One table contains just
the company contact information,

42
00:02:23.412 --> 00:02:26.918
one table contains information
about the loyalty program,

43
00:02:26.918 --> 00:02:30.450
one table contains information
about distribution centers.

44
00:02:30.450 --> 00:02:33.550
One table contains information about
Egger's Roast Coffee employees who

45
00:02:33.550 --> 00:02:34.760
take the orders.

46
00:02:34.760 --> 00:02:37.800
And one table contains
the order information.

47
00:02:37.800 --> 00:02:40.640
We would leave out any of
the calculated fields to save space,

48
00:02:40.640 --> 00:02:42.490
because they could be calculated
whenever we need them.

49
00:02:43.640 --> 00:02:47.190
If we set up our data this way, you can
see that each one of our smaller tables

50
00:02:47.190 --> 00:02:50.900
would have to have a column that would
link it to the order table in some way.

51
00:02:50.900 --> 00:02:53.030
Those linking columns
are indicated here in red.

52
00:02:54.300 --> 00:02:57.150
Let's consider some of the benefits
of breaking our spreadsheet down to

53
00:02:57.150 --> 00:02:58.720
theme tables.

54
00:02:58.720 --> 00:03:00.170
With this new organization,

55
00:03:00.170 --> 00:03:03.710
if we needed to change information about
an employee, we would only have to change

56
00:03:03.710 --> 00:03:07.100
it once in the employee table rather than
having to search and replace a value in

57
00:03:07.100 --> 00:03:10.450
the entire column of over a million rows
every time we wanted to make a change.

58
00:03:11.450 --> 00:03:14.740
We can also add distribution centers to
our database without having to add most of

59
00:03:14.740 --> 00:03:16.620
the blank rows to the main table.

60
00:03:16.620 --> 00:03:19.360
And we can easily add new information
about those distribution centers

61
00:03:19.360 --> 00:03:19.910
to the data set,

62
00:03:19.910 --> 00:03:24.610
like their addresses, without having
to take up much disc storage space.

63
00:03:24.610 --> 00:03:28.280
In addition, it's clear how you could
keep information about historic contact,

64
00:03:28.280 --> 00:03:31.990
even if a store never ended up going
through with the sales process.

65
00:03:31.990 --> 00:03:36.090
Further, we have saved lots of space by
not having to repeat all the information

66
00:03:36.090 --> 00:03:39.270
in the company contact, loyalty program,
distribution center and

67
00:03:39.270 --> 00:03:42.540
Egger's Roast Coffee employees table and
every single row of the orders table.

68
00:03:43.780 --> 00:03:46.310
As you can see,
organizing the dataset in this way

69
00:03:46.310 --> 00:03:48.550
solves a lot of the problems we
talked about in the last video.

70
00:03:48.550 --> 00:03:53.120
In addition, organizing the dataset
into smaller themed tables

71
00:03:53.120 --> 00:03:56.300
makes relational databases
very powerful in another way.

72
00:03:56.300 --> 00:03:58.970
But this consequence is also
probably not very intuitive.

73
00:04:00.290 --> 00:04:01.920
Here's a summary.

74
00:04:01.920 --> 00:04:05.820
Computers don't yet run on magic although
admittedly it often seems like they do.

75
00:04:06.850 --> 00:04:09.710
In order to have a computer program
do something like link up tables for

76
00:04:09.710 --> 00:04:13.390
you, you have to have a way of
telling the computer how to do that.

77
00:04:13.390 --> 00:04:15.990
You have to be able to program
in the appropriate rules and

78
00:04:15.990 --> 00:04:18.710
operations that will lead
to the outcomes you want.

79
00:04:18.710 --> 00:04:22.360
It turns out that thinking of data as
groups of related items that can interact

80
00:04:22.360 --> 00:04:26.030
allows programmers to take advantage of
the mathematical theory called set theory

81
00:04:26.030 --> 00:04:28.970
and a kind of algebra called relational
algebra to write an elegant and

82
00:04:28.970 --> 00:04:32.010
complete programming language for
each reading information.

83
00:04:32.010 --> 00:04:34.910
SInce the theme of set theory
will occur again in the course,

84
00:04:34.910 --> 00:04:37.640
I'd like to take a moment to give
you an intuition for how set theory

85
00:04:37.640 --> 00:04:41.290
forms the basis of relational databases,
even if we don't go over any of the math.

86
00:04:43.030 --> 00:04:46.820
Mathematical set theory defines a set as
a collection of unique objects that have

87
00:04:46.820 --> 00:04:49.950
something in common or
that follow a common rule.

88
00:04:49.950 --> 00:04:51.880
A set can be a collection
of anything really,

89
00:04:51.880 --> 00:04:55.660
as long as the things in the set
clearly have common features.

90
00:04:55.660 --> 00:04:58.750
If we think of each of our database
tables as collection of columns and

91
00:04:58.750 --> 00:05:02.730
collections of rows, treating a table
as two intersecting collections or

92
00:05:02.730 --> 00:05:04.880
sets seems like a reasonable thing to do.

93
00:05:05.880 --> 00:05:08.690
Relational algebra tells you
how you can manipulate sets.

94
00:05:08.690 --> 00:05:12.070
In other words, do things like subtract
one from another, add them together, and

95
00:05:12.070 --> 00:05:13.750
find where they overlap.

96
00:05:13.750 --> 00:05:17.790
So if each table is a set of columns and
rows we can use relational algebra

97
00:05:17.790 --> 00:05:21.370
to write a computer program to tell the
computer how to select subsets of data for

98
00:05:21.370 --> 00:05:24.860
us and,
how to combine sets of data across tables.

99
00:05:24.860 --> 00:05:27.460
The words we use in our commands
the database will reflect

100
00:05:27.460 --> 00:05:28.450
this relational algebra.

101
00:05:29.620 --> 00:05:33.380
Now here's the really cool part,
set theory's a form of logic.

102
00:05:33.380 --> 00:05:38.240
It's said that set theory was founded
by the single paper in 1874, so it's

103
00:05:38.240 --> 00:05:42.580
been studied for a really long time and
is really well understood at this point.

104
00:05:42.580 --> 00:05:45.950
Therefore, we know how to write algorithms
that come up with the mathematically

105
00:05:45.950 --> 00:05:48.380
optimal way to manipulate subsets.

106
00:05:48.380 --> 00:05:52.850
By basing our databases on set theory,
we can take advantage of these algorithms.

107
00:05:52.850 --> 00:05:56.140
What this means is that relational
databases based on set theory,

108
00:05:56.140 --> 00:05:58.070
as long as they are set up correctly,

109
00:05:58.070 --> 00:06:01.500
can pull together the subsets of data
we ask for really really quickly

110
00:06:01.500 --> 00:06:06.260
in a mathematically optimal way, even if
those data sets reside in multiple tables.

111
00:06:06.260 --> 00:06:09.520
That's why relational databases are still
some of the fastest databases out

112
00:06:09.520 --> 00:06:12.560
there for manipulating and
recombining stored tabular data.

113
00:06:13.970 --> 00:06:17.460
If at some point in your career you become
in interested in optimizing the speed in

114
00:06:17.460 --> 00:06:20.540
which the database you are working
with outputs information

115
00:06:20.540 --> 00:06:23.370
you will start working with
these algorithms directly.

116
00:06:23.370 --> 00:06:26.460
There's a command that asks the database
to tell how it would implement

117
00:06:26.460 --> 00:06:29.450
a hypothetical query and
you can use that information to write

118
00:06:29.450 --> 00:06:31.830
an alternative version of
the command that can be run faster.

119
00:06:32.850 --> 00:06:36.070
Even if you don't focus on set theory
algorithms much in the way you end up

120
00:06:36.070 --> 00:06:38.230
interacting with your company's database.

121
00:06:38.230 --> 00:06:41.370
The database will be
configured to abide by as many

122
00:06:41.370 --> 00:06:43.610
of the requirements of
set theory as possible.

123
00:06:43.610 --> 00:06:45.320
So that the algorithms can
be taken advantage of.

124
00:06:45.320 --> 00:06:48.260
It will be useful to you to know
what those requirements are.

125
00:06:49.590 --> 00:06:50.320
First of all,

126
00:06:50.320 --> 00:06:53.620
single tables should represent
the smallest logical part of a data set.

127
00:06:54.690 --> 00:06:58.280
Next, each column in a table
must represent a unique category

128
00:06:58.280 --> 00:06:59.790
of information.

129
00:06:59.790 --> 00:07:03.220
Each row in a table must represent unique
instance of that information as well.

130
00:07:04.310 --> 00:07:06.930
Another important requirement
is that order of columns or

131
00:07:06.930 --> 00:07:08.980
row in a table can't matter.

132
00:07:08.980 --> 00:07:11.650
This will allow the database to pull
them together in whatever order or

133
00:07:11.650 --> 00:07:13.429
fashion it determines will be the fastest.

134
00:07:14.600 --> 00:07:17.230
Relational databases have some
additional advantages beyond their

135
00:07:17.230 --> 00:07:20.920
principal method for outputting
subsets of information we care about.

136
00:07:20.920 --> 00:07:24.470
To start, relational database systems have
built in some features that help maintain

137
00:07:24.470 --> 00:07:26.140
data integrity.

138
00:07:26.140 --> 00:07:28.700
For example,
when you set up a relational database,

139
00:07:28.700 --> 00:07:31.770
you define exactly what type
of data go into each column.

140
00:07:31.770 --> 00:07:35.210
And that database can prevent you from
putting another type of data in there.

141
00:07:35.210 --> 00:07:38.310
That means you wouldn't be able to write
a number by accident when you were suppose

142
00:07:38.310 --> 00:07:39.080
to enter a word.

143
00:07:40.120 --> 00:07:43.840
You can also define whether or
not a column will allow no values.

144
00:07:43.840 --> 00:07:47.750
Further, relational databases allow you
to specify who has permission to access

145
00:07:47.750 --> 00:07:53.240
certain part of the database in exactly in
what ways overall, what this means is that

146
00:07:53.240 --> 00:07:56.500
as long as we can figure out how to put
the data we care about into collections of

147
00:07:56.500 --> 00:08:00.460
tables, relational databases provide
a very powerful way to store and

148
00:08:00.460 --> 00:08:04.130
retrieve our data in an extremely safe and
reliable fashion.

149
00:08:04.130 --> 00:08:06.500
They pretty much solve all
the problems spreadsheets don't.

150
00:08:07.540 --> 00:08:11.360
That's why, as we heard Ryan tell us at
the beginning of the course, almost every

151
00:08:11.360 --> 00:08:15.130
company uses a relational database for
some part of the data in their company.

152
00:08:15.130 --> 00:08:17.870
They are mathematically elegant,
and they work really well for

153
00:08:17.870 --> 00:08:20.070
data that fit into columns and rows.

154
00:08:20.070 --> 00:08:21.910
That's also why it will benefit you so

155
00:08:21.910 --> 00:08:25.260
much as a data analyst to learn how to
interact with these types of databases.