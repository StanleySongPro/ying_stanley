WEBVTT

1
00:00:04.132 --> 00:00:08.690
In the last video we learned
how to read ER diagrams.

2
00:00:08.690 --> 00:00:12.640
ER diagrams represent the concepts that
database architects have to implement, but

3
00:00:12.640 --> 00:00:16.070
they don't yet represent how
a database is actually organized.

4
00:00:16.070 --> 00:00:19.910
Although a well designed database will
have an ER diagram that looks very similar

5
00:00:19.910 --> 00:00:22.040
to what the corresponding
database ends up looking like.

6
00:00:23.040 --> 00:00:26.000
To describe the model of what
a database truly looks like,

7
00:00:26.000 --> 00:00:27.930
you use a relational schema.

8
00:00:27.930 --> 00:00:29.960
In this video we will
learn how to interpret and

9
00:00:29.960 --> 00:00:31.490
make these relational schemas.

10
00:00:32.840 --> 00:00:36.970
The critical components of a relational
schema are tables, primary keys and

11
00:00:36.970 --> 00:00:38.340
foreign keys.

12
00:00:38.340 --> 00:00:40.930
To get a feel for how these
components relate to the information

13
00:00:40.930 --> 00:00:44.975
in an ER diagram, let's examine how
one of the ER diagrams we saw in

14
00:00:44.975 --> 00:00:47.750
a previous video would be translated
into a relational schema.

15
00:00:49.590 --> 00:00:53.080
You can see that in general,
each entity in the ER diagram

16
00:00:53.080 --> 00:00:55.990
has been turned into a table
in the relational scheme.

17
00:00:55.990 --> 00:00:59.900
Before I use that word table again though,
I have to tell you that some people would

18
00:00:59.900 --> 00:01:03.330
not approve of using that word when
talking about relational schemas.

19
00:01:03.330 --> 00:01:04.650
Let me explain their disapproval.

20
00:01:05.780 --> 00:01:09.299
Relational schemas can be thought
of as blueprints for database.

21
00:01:09.299 --> 00:01:13.157
A blueprint for a car tells you important
information about how a car is going to be

22
00:01:13.157 --> 00:01:16.210
built, but
it isn't equivalent to a built car.

23
00:01:16.210 --> 00:01:19.400
The reason why is that building
a car takes a lot more work and

24
00:01:19.400 --> 00:01:21.939
draws upon a lot more information
than is included in the blueprint.

25
00:01:22.940 --> 00:01:26.450
Plus the blueprint is a representation of
something that will be made in the future

26
00:01:26.450 --> 00:01:30.160
but the car is a concrete
object that already exists.

27
00:01:30.160 --> 00:01:34.070
Like wise a relational schema tells you
important information about how a database

28
00:01:34.070 --> 00:01:38.320
is going to be organized, but
it isn't equivalent to a built database.

29
00:01:38.320 --> 00:01:41.560
Building the database requires more
work and detailed information than is

30
00:01:41.560 --> 00:01:46.230
represented by the relational schema plus
a relational schema is usually a plan.

31
00:01:46.230 --> 00:01:48.010
But a database is something
that is already made.

32
00:01:48.010 --> 00:01:52.420
If it is important to you to differentiate
between the logical ideas behind

33
00:01:52.420 --> 00:01:55.000
a database design, and
the physical implementation of

34
00:01:55.000 --> 00:01:59.510
those ideas in a database, you will use
different vocabulary for the concepts used

35
00:01:59.510 --> 00:02:03.290
in the database design versus
the steps used in database creation.

36
00:02:03.290 --> 00:02:06.130
This is the reason some people
who get upset at the idea

37
00:02:06.130 --> 00:02:08.620
of describing the box in
a relational schema as a table.

38
00:02:10.300 --> 00:02:13.576
The technical term for the phenomenon
represented by a box in a relational

39
00:02:13.576 --> 00:02:17.880
schemea is relation, which is a term
that once again comes from set theory.

40
00:02:17.880 --> 00:02:21.130
A relation is a logical idea that
serves as the organization for

41
00:02:21.130 --> 00:02:23.740
the physical basis of the database.

42
00:02:23.740 --> 00:02:27.060
For our purposes in this course, it is
not important to emphasize the difference

43
00:02:27.060 --> 00:02:30.760
between the theoretical design of a
database and it's physical implementation.

44
00:02:30.760 --> 00:02:33.480
So I will refer to
the relation as a table.

45
00:02:33.480 --> 00:02:36.600
In general, in fact, I will tell you
what the technical descriptions of

46
00:02:36.600 --> 00:02:41.120
the phenomena depicted in the relational
schema are, but I, like many database

47
00:02:41.120 --> 00:02:45.310
users as opposed to database designers,
will use common names to talk about them.

48
00:02:45.310 --> 00:02:46.650
This will make it much easier for

49
00:02:46.650 --> 00:02:51.150
us to achieve the goals of the course
which is learn SQL not to make databases.

50
00:02:51.150 --> 00:02:54.620
Nonetheless, you should be aware that many
people in the database world feel strongly

51
00:02:54.620 --> 00:02:57.620
that words like table, rows, and
columns are not appropriate for

52
00:02:57.620 --> 00:02:59.590
describing relational schemas.

53
00:02:59.590 --> 00:03:02.400
I'll make sure you know the technical
terminology too in case you need to

54
00:03:02.400 --> 00:03:03.910
communicate with people
who have that view.

55
00:03:05.330 --> 00:03:08.150
With that issue out of the way let's
turn back to what I usually call

56
00:03:08.150 --> 00:03:10.420
tables in relational schemas.

57
00:03:10.420 --> 00:03:13.070
Each table, or
relation in theoretical terms,

58
00:03:13.070 --> 00:03:16.490
has a set of columns which
can also be called fields.

59
00:03:16.490 --> 00:03:20.440
These columns represent the attributes
we saw in the ER diagrams before and

60
00:03:20.440 --> 00:03:23.530
it turns out that they are formally called
attributes in relational schemas as well.

61
00:03:24.730 --> 00:03:27.668
Each entry in a table is a row or
a record.

62
00:03:27.668 --> 00:03:32.860
The formal logical term for an entity and
a table or a relation is a tuple.

63
00:03:32.860 --> 00:03:36.270
In theory,
no Tuple can be duplicated in a relation.

64
00:03:36.270 --> 00:03:40.680
In practice though, rows can be duplicated
in tables, unknowingly for analysts.

65
00:03:41.720 --> 00:03:42.690
And both theory and

66
00:03:42.690 --> 00:03:46.470
practice, the columns in a table are not
allowed to have a particular order.

67
00:03:46.470 --> 00:03:48.450
No matter what it might
look like sometimes,

68
00:03:48.450 --> 00:03:51.540
the rows in a table do not have
a particular order either.

69
00:03:51.540 --> 00:03:54.553
Both columns and rows must be independent
for set theory to work and for

70
00:03:54.553 --> 00:03:58.580
the database to be able to return queries
correctly and as quickly as possible.

71
00:03:58.580 --> 00:03:59.402
As a consequence,

72
00:03:59.402 --> 00:04:02.390
remember that you can never trust
the order in which data are output

73
00:04:02.390 --> 00:04:05.743
from a query unless you specifically tell
the query to output them in a certain way.

74
00:04:07.010 --> 00:04:08.270
The critical thing to look out for

75
00:04:08.270 --> 00:04:11.780
in a relational schema is that each
table must have a primary key.

76
00:04:11.780 --> 00:04:14.680
The primary key for a table will be
one of the columns we talked about

77
00:04:14.680 --> 00:04:19.260
in a previous video that has a unique
identifier for every row in that table.

78
00:04:19.260 --> 00:04:22.630
The primary key will be underlined in
a relational schema just like it was in

79
00:04:22.630 --> 00:04:23.910
the ER diagrams.

80
00:04:23.910 --> 00:04:26.690
The critical difference between the ER
diagrams and a relational schemas,

81
00:04:26.690 --> 00:04:30.090
though, is that although you were supposed
to underline all unique attributes in

82
00:04:30.090 --> 00:04:33.750
the ER diagram, only one unique column
in a table of a relational schema or

83
00:04:33.750 --> 00:04:36.380
database can be labelled as a primary key.

84
00:04:36.380 --> 00:04:39.180
The only exception is if you need
multiple columns to make each row in

85
00:04:39.180 --> 00:04:39.790
a table unique.

86
00:04:41.040 --> 00:04:44.522
The reason you can only have one primary
key, is that the database software

87
00:04:44.522 --> 00:04:47.460
uses the primary key in special
ways to ensure data integrity.

88
00:04:47.460 --> 00:04:50.607
To maintain this integrity,
primary keys are configured so

89
00:04:50.607 --> 00:04:53.140
that they cannot contain
any missing values.

90
00:04:53.140 --> 00:04:56.190
Although missing values can sneak in
occasionally if the database is configured

91
00:04:56.190 --> 00:04:57.750
too flexibly.

92
00:04:57.750 --> 00:05:02.042
In contrast, other unique columns can
be configured to allow for null values.

93
00:05:02.042 --> 00:05:05.470
Despite the null values you can still link
tables using unique columns that are not

94
00:05:05.470 --> 00:05:08.210
primary keys though when
you're on these queries.

95
00:05:08.210 --> 00:05:11.470
To help you with these links it is useful
to mark unique columns in your schema with

96
00:05:11.470 --> 00:05:13.310
a U next to their column titles so

97
00:05:13.310 --> 00:05:15.680
that you know which ones can be use
to link tables in your queries.

98
00:05:16.890 --> 00:05:20.820
The next important concept to know
about is the concept of a foreign key.

99
00:05:20.820 --> 00:05:23.840
Foreign keys are used to
link tables to other tables.

100
00:05:23.840 --> 00:05:28.280
They accomplish this by having values that
refer to unique IDs and other tables.

101
00:05:28.280 --> 00:05:30.020
In our Egger's Reskov example,

102
00:05:30.020 --> 00:05:34.655
contact ID was a foreign key in the Orders
table that let us link each order

103
00:05:34.655 --> 00:05:37.795
with information about the customer
contact in the customer contact table.

104
00:05:38.995 --> 00:05:42.665
You indicate foreign keys in relational
schemas by drawing arrows from the foreign

105
00:05:42.665 --> 00:05:45.975
key in one table to the primary
key it refers to in another table.

106
00:05:47.225 --> 00:05:50.343
It is good practice to write
the abbreviation FK next to the name of

107
00:05:50.343 --> 00:05:52.849
a foreign key column as well, but
some people do leave that out.

108
00:05:54.000 --> 00:05:55.550
It's important to know
that foreign keys and

109
00:05:55.550 --> 00:05:59.420
primary keys to which they match up
do not have to use the same title.

110
00:05:59.420 --> 00:06:02.630
Hopefully a good database designer will
at least make the names seem similar but

111
00:06:02.630 --> 00:06:04.490
you can't rely on that being the case.

112
00:06:04.490 --> 00:06:06.778
So that's one of the reasons
relational schemes can be so

113
00:06:06.778 --> 00:06:08.983
helpful to you as an analyst
trying to query your data.

114
00:06:08.983 --> 00:06:11.701
Now that you know the basic
components of relational schema,

115
00:06:11.701 --> 00:06:14.629
let's look at some additional
examples of relational schemas and

116
00:06:14.629 --> 00:06:16.970
see if we can figure out what they mean.

117
00:06:16.970 --> 00:06:18.770
We'll start with a relatively
straight forward one.

118
00:06:19.810 --> 00:06:23.870
Here, our database is keeping track
of employees and their phone numbers.

119
00:06:23.870 --> 00:06:28.030
Each employee is identified by his or
her own unique employee ID.

120
00:06:28.030 --> 00:06:29.520
Each phone number is unique on its own.

121
00:06:30.600 --> 00:06:33.760
In a query, phone numbers can
be matched up to employees

122
00:06:33.760 --> 00:06:37.190
using the employee ID number
that exists in both tables.

123
00:06:37.190 --> 00:06:38.110
One thing you might notice,

124
00:06:38.110 --> 00:06:40.760
though, is that there's nothing on
the relational schema that says how many

125
00:06:40.760 --> 00:06:42.970
employees can matchup with a phone number.

126
00:06:42.970 --> 00:06:45.590
It's possible that two
employees can live together and

127
00:06:45.590 --> 00:06:47.250
share the same home phone number.

128
00:06:47.250 --> 00:06:49.840
It's also possible that a single
employee could have provided multiple

129
00:06:49.840 --> 00:06:51.040
phone numbers.

130
00:06:51.040 --> 00:06:54.460
This version of the relational schema
doesn't provide that information.

131
00:06:54.460 --> 00:06:57.470
A version that did include this
information we use the same notation as we

132
00:06:57.470 --> 00:06:59.300
learned about in the ER diagrams.

133
00:06:59.300 --> 00:07:02.950
As an example,
here we see that each employee

134
00:07:02.950 --> 00:07:07.210
must have a minimum of one phone number,
but can have multiple phone numbers.

135
00:07:08.300 --> 00:07:13.510
Each phone number must be linked
up to exactly one single employee.

136
00:07:15.240 --> 00:07:18.340
Many relational schemas do not
include giardinelli information.

137
00:07:18.340 --> 00:07:21.750
That's another reason why it's useful
to understand both ER diagrams and

138
00:07:21.750 --> 00:07:22.890
relational schemas.

139
00:07:22.890 --> 00:07:25.320
And why you should ask for both when
you start working with a database.

140
00:07:26.770 --> 00:07:31.100
Let's look at how a weak entity would
be represented in a relational schema.

141
00:07:31.100 --> 00:07:34.830
Here our database is keeping track
of buildings and apartments.

142
00:07:34.830 --> 00:07:38.763
Each apartment is uniquely identified by
a combination of the apartment number in

143
00:07:38.763 --> 00:07:41.850
the apartment table with the building
ID in the building table.

144
00:07:41.850 --> 00:07:44.924
You can discern this from the fact
that both apartment ID and

145
00:07:44.924 --> 00:07:48.676
building ID are underlined in
the apartment table, and that in addition

146
00:07:48.676 --> 00:07:53.830
building ID in this table is a foreign key
to the building ID in the building table.

147
00:07:53.830 --> 00:07:57.180
You might remember this example because
the relational schema we just made

148
00:07:57.180 --> 00:08:00.870
depicts the weak entity we discussed
in this ER diagram in a previous video.

149
00:08:02.400 --> 00:08:05.290
Let's look at one more
example of relational schema.

150
00:08:05.290 --> 00:08:09.055
Here our database is keeping
track of students and classes.

151
00:08:09.055 --> 00:08:12.400
It also has another table called enrolled
in that only has foreign keys as

152
00:08:12.400 --> 00:08:13.740
attributes.

153
00:08:13.740 --> 00:08:16.650
This type of mapping table has to
be implemented when the entities in

154
00:08:16.650 --> 00:08:21.600
the corresponding ER diagram have what
is called a many to many relationship.

155
00:08:21.600 --> 00:08:24.770
In this case each student can
enroll in many classes and

156
00:08:24.770 --> 00:08:26.540
each class can have many
students enrolled in it.

157
00:08:27.570 --> 00:08:30.630
Under these circumstances there
is no way to follow the rule

158
00:08:30.630 --> 00:08:32.810
that primary keys must
not be duplicated and

159
00:08:32.810 --> 00:08:36.520
still included a foreign key in
the same table as the primary key.

160
00:08:36.520 --> 00:08:41.260
Therefore, a mapping table has nothing but
one composite primary keys in it.

161
00:08:41.260 --> 00:08:44.140
The composite key is made up
of two foreign keys that link

162
00:08:44.140 --> 00:08:48.000
to the primary keys of the two tables
of the many-to-many relationship.

163
00:08:48.000 --> 00:08:51.280
Whenever you see a mapping table like this
in a database, it's a clue of the columns

164
00:08:51.280 --> 00:08:54.670
in the tables that links up can have
multiple instances of one another.

165
00:08:54.670 --> 00:08:58.370
I have included some relational scheme

166
00:08:58.370 --> 00:09:02.580
exercises with the course materials
that were once again donated by

167
00:09:02.580 --> 00:09:05.500
professor at Quinlan school of business
at Loyola University, Chicago.

168
00:09:06.600 --> 00:09:09.318
These exercises are derived from
this textbook pictured here.

169
00:09:09.318 --> 00:09:13.860
Like the ER diagram exercises you
are not required to complete these.

170
00:09:13.860 --> 00:09:16.250
But I highly recommend that you do so.

171
00:09:16.250 --> 00:09:19.030
Pay particular attention to
location of the foreign keys.

172
00:09:19.030 --> 00:09:21.620
And think carefully about what
columns you would need to reference

173
00:09:21.620 --> 00:09:25.470
if you wanted to link columns separated
into different tables together.

174
00:09:25.470 --> 00:09:28.818
Since relational schemas are the closest
things you have to map of your database,

175
00:09:28.818 --> 00:09:31.960
learning how to read them comfortably
will make it much easier to navigate your

176
00:09:31.960 --> 00:09:34.380
database with effective queries later.

177
00:09:34.380 --> 00:09:37.540
You should also be aware that you will
often be given access to a database

178
00:09:37.540 --> 00:09:41.630
without a relational schema or any kind of
description of what is in the database.

179
00:09:41.630 --> 00:09:43.290
When this happens it will be useful for

180
00:09:43.290 --> 00:09:45.820
you to know how to generate
a relational schema yourself.

181
00:09:45.820 --> 00:09:48.840
So that you can refer to it when
you start doing your data analysis.

182
00:09:48.840 --> 00:09:52.246
In the next video we will show you
how to make one using ERD Plus,

183
00:09:52.246 --> 00:09:56.053
an online tool that created to
help people design databases.